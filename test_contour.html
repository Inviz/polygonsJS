<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Testing Contour Extraction</title>
    <link rel="stylesheet" href="qunit-1.12.0.css">
    <style>
        .svgTest td {
            border: solid 1px green;
        }

        .svgTest th {
            text-align: center !important; /*some qunit selector use an #id, so we have to force it*/
        }

        path {
            fill: none;
            stroke: black;
            vector-effect: non-scaling-stroke;
        }
    </style>
</head>
<body>
<canvas id="canvas" width="1811" height="1181"></canvas>
<img id="img" src="testImage.png" style="display:none;">

<script src="jquery-1.10.2.js"></script>
<script src="simplify.js"></script>
<script>
    $(function () {
        var nextId = 1;
        var image = $('#img')[0];
        var canvas = $('#canvas')[0];
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, image.width, image.height);
        var imageData = ctx.getImageData(0, 0, image.width, image.height);

        function randomColor() {
            return 'rgb(' + Math.round(Math.random() * 255) + ',' + Math.round(Math.random() * 255) + ',' + Math.round(Math.random() * 255) + ')';
        }

        function getPix(x, y) {
            var pixIndex = y * imageData.width + x;
            return !!imageData.data[pixIndex * 4];
        }

        function searchInterceptingRanges(x1, x2, candidates, startIndex) {
            var parents = [];
            for (var i = startIndex; i < candidates.length; i++)
                if (!(candidates[i].right.x < x1 || candidates[i].left.x > x2))
                    parents.push(candidates[i]);
            return parents;
        }

        function setLastChild(node, sucessor) {
            //if successor the fist child of his parent, then his predecessor is the last child of his parent if he's got any.
            if (sucessor == null || sucessor.isFirstChild || !sucessor.hasParents)
                node.isLastChild = node.hasParents;
        }

        function closeRange(x1, x2, y, currentRange, previousLine, previousRowIndex) {
            var previous = currentRange[currentRange.length - 1];
            var node = {span: [x1, x2], y: y, id: nextId++, left: {x: x1, y: y}, right: {x: x2, y: y}};
            currentRange.push(node);
            var parents = searchInterceptingRanges(x1, x2, previousLine, previousRowIndex);
            node.parents = parents;
            if (parents.length)
                node.hasParents = true;
            if (parents.length && !parents[0].hasChildren)
                node.isFirstChild = true;
            if (previous && parents) {
                var previousLastParent = previous.parents[previous.parents.length - 1];
                if (previousLastParent && previousLastParent == parents[0])
                    previous.nextSibling = node;
            }
            for (var i = 0; i < parents.length; i++) {
                parents[i].hasChildren = true;
                if (i + 1 < parents.length)
                    parents[i + 1].previousSibling = parents[i];
            }
            if (previous)
                setLastChild(previous, node);
        }

        function newPreviousRowIndex(x, currentIndex, previousRow) {
            for (var i = currentIndex; i < previousRow.length; i++)
                if (!previousRow[i].right.x < x)
                    break;
            return i;
        }

        function extractContours() {
            console.time('scan');
            var polygons = [];
            var previousRow = [];
            for (var j = 0; j < imageData.height; j++) {
                var previousRowIndex = 0;
                var currentRow = [];
                var previousPix = 0;
                for (var i = 0; i < imageData.width; i++) {
                    var pix = getPix(i, j);
                    if (i != 0 && pix != previousPix) {
                        previousRowIndex = newPreviousRowIndex(i, previousRowIndex, previousRow);
                        var startX;
                        if (pix)
                            startX = i - 1;
                        else
                            closeRange(startX, i, j, currentRow, previousRow, previousRowIndex);
                    }
                    previousPix = pix;
                }
                if (currentRow.length)
                    setLastChild(currentRow[currentRow.length - 1], null);
                if (j - 1 >= 0)
                    handleRow(previousRow, polygons);
                previousRow = currentRow;
            }
            handleRow(previousRow, polygons);
            console.timeEnd('scan');
            return extractPolygons(polygons);
        }

        function creationEvent(span, leftToRight, polygons) {
            polygons.push({id: 'p' + Math.random(), firstPoint: span.right});
            var polygonIndex = polygons.length - 1;
            if (leftToRight)
                span.right.next = span.nextSibling.left;
            else
                span.right.next = span.left;
            span.right.polygonIndex = polygonIndex;
            span.right.next.polygonIndex = polygonIndex;
        }

        function fusionEvent(span, leftToRight, polygons) {
            if (leftToRight)
                span.left.next = span.right;
            else
                span.left.next = span.previousSibling.right;
            polygons[span.left.next] = polygons[span.left.polygonIndex];
        }

        function handleRow(row, polygons) {
            for (var i = 0; i < row.length; i++) {
                var span = row[i];
                if (span.parents.length == 0)
                    creationEvent(span, false, polygons);
                else {
                    var firstParent = span.parents[0];
                    if (span.isFirstChild) {
                        firstParent.left.next = span.left;
                        span.left.polygonIndex = firstParent.left.polygonIndex;
                    }
                    var lastParent = span.parents[span.parents.length - 1];
                    if (span.isLastChild) {
                        span.right.next = lastParent.right;
                        span.right.polygonIndex = lastParent.right.polygonIndex;
                    }
                }
                if (!span.hasChildren)
                    fusionEvent(span, true, polygons);
                if (span.nextSibling)
                    creationEvent(span, true, polygons);
                if (span.previousSibling)
                    fusionEvent(span, false, polygons);
            }
        }

        function extractPolygons(unfilteredPolygons) {
            console.time('poly filtering');
            var seenPolygons = {};
            var polygons = [];
            for (var i = 0; i < unfilteredPolygons.length; i++) {
                var rawPoly = unfilteredPolygons[i];
                var poly = [];
                if (seenPolygons[rawPoly.id])
                    continue;
                seenPolygons[rawPoly.id] = true;
                var current = rawPoly.firstPoint;
                do {
                    current = current.next;
                    poly.push({x: current.x, y: current.y});
                } while (current != rawPoly.firstPoint);
                polygons.push(poly);
            }
            console.timeEnd('poly filtering');
            return polygons;
        }

        function displayPolygons(polygons) {
            console.log(polygons.length);
            ctx.lineWidth = 3;
            for (var i = 0; i < polygons.length; i++) {
                var color = randomColor();
                var poly = polygons[i];
                ctx.strokeStyle = color;
                ctx.beginPath();
                ctx.moveTo(poly[0].x, poly[0].y);
                for (var j = 0; j < poly.length; j++)
                    ctx.lineTo(poly[j].x, poly[j].y);
                ctx.lineTo(poly[0].x, poly[0].y);
                ctx.stroke();
            }
        }

        displayPolygons(extractContours());
    });
</script>
</body>
</html>